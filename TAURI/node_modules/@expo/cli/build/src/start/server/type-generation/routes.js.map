{"version":3,"sources":["../../../../../src/start/server/type-generation/routes.ts"],"sourcesContent":["import fs from 'fs/promises';\nimport { debounce } from 'lodash';\nimport { Server } from 'metro';\nimport path from 'path';\n\nimport { unsafeTemplate } from '../../../utils/template';\nimport { ServerLike } from '../BundlerDevServer';\nimport { metroWatchTypeScriptFiles } from '../metro/metroWatchTypeScriptFiles';\n\n// /test/[...param1]/[param2]/[param3] - captures [\"param1\", \"param2\", \"param3\"]\nexport const CAPTURE_DYNAMIC_PARAMS = /\\[(?:\\.{3})?(\\w*?)[\\]$]/g;\n// /[...param1]/ - Match [...param1]\nexport const CATCH_ALL = /\\[\\.\\.\\..+?\\]/g;\n// /[param1] - Match [param1]\nexport const SLUG = /\\[.+?\\]/g;\n// /(group1,group2,group3)/test - match (group1,group2,group3)\nexport const ARRAY_GROUP_REGEX = /\\(\\w+?,.*?\\)/g;\n// /(group1,group2,group3)/test - captures [\"group1\", \"group2\", \"group3\"]\nexport const CAPTURE_GROUP_REGEX = /[\\\\(,](\\w+?)(?=[,\\\\)])/g;\n\nexport interface SetupTypedRoutesOptions {\n  server: ServerLike;\n  metro?: Server | null;\n  typesDirectory: string;\n  projectRoot: string;\n  routerDirectory: string;\n}\n\nexport async function setupTypedRoutes({\n  server,\n  metro,\n  typesDirectory,\n  projectRoot,\n  routerDirectory,\n}: SetupTypedRoutesOptions) {\n  const appRoot = path.join(projectRoot, routerDirectory);\n\n  const { filePathToRoute, staticRoutes, dynamicRoutes, addFilePath } =\n    getTypedRoutesUtils(appRoot);\n\n  if (metro) {\n    // Setup out watcher first\n    metroWatchTypeScriptFiles({\n      projectRoot: appRoot,\n      server,\n      metro,\n      eventTypes: ['add', 'delete', 'change'],\n      async callback({ filePath, type }) {\n        let shouldRegenerate = false;\n        if (type === 'delete') {\n          const route = filePathToRoute(filePath);\n          staticRoutes.delete(route);\n          dynamicRoutes.delete(route);\n          shouldRegenerate = true;\n        } else {\n          shouldRegenerate = addFilePath(filePath);\n        }\n\n        if (shouldRegenerate) {\n          regenerateRouterDotTS(\n            typesDirectory,\n            new Set([...staticRoutes.values()].flatMap((v) => Array.from(v))),\n            new Set([...dynamicRoutes.values()].flatMap((v) => Array.from(v))),\n            new Set(dynamicRoutes.keys())\n          );\n        }\n      },\n    });\n  }\n\n  // Do we need to walk the entire tree on startup?\n  // Idea: Store the list of files in the last write, then simply check Git for what files have changed\n  await walk(appRoot, addFilePath);\n\n  regenerateRouterDotTS(\n    typesDirectory,\n    new Set([...staticRoutes.values()].flatMap((v) => Array.from(v))),\n    new Set([...dynamicRoutes.values()].flatMap((v) => Array.from(v))),\n    new Set(dynamicRoutes.keys())\n  );\n}\n\n/**\n * Generate a router.d.ts file that contains all of the routes in the project.\n * Should be debounced as its very common for developers to make changes to multiple files at once (eg Save All)\n */\nconst regenerateRouterDotTS = debounce(\n  (\n    typesDir: string,\n    staticRoutes: Set<string>,\n    dynamicRoutes: Set<string>,\n    dynamicRouteTemplates: Set<string>\n  ) => {\n    fs.writeFile(\n      path.resolve(typesDir, './router.d.ts'),\n      getTemplateString(staticRoutes, dynamicRoutes, dynamicRouteTemplates)\n    );\n  },\n  100\n);\n\n/*\n * This is exported for testing purposes\n */\nexport function getTemplateString(\n  staticRoutes: Set<string>,\n  dynamicRoutes: Set<string>,\n  dynamicRouteTemplates: Set<string>\n) {\n  return routerDotTSTemplate({\n    staticRoutes: setToUnionType(staticRoutes),\n    dynamicRoutes: setToUnionType(dynamicRoutes),\n    dynamicRouteParams: setToUnionType(dynamicRouteTemplates),\n  });\n}\n\n/**\n * Utility functions for typed routes\n *\n * These are extracted for easier testing\n */\nexport function getTypedRoutesUtils(appRoot: string) {\n  /*\n   * staticRoutes are a map where the key if the route without groups and the value\n   *   is another set of all group versions of the route. e.g,\n   *    Map([\n   *      [\"/\", [\"/(app)/(notes)\", \"/(app)/(profile)\"]\n   *    ])\n   */\n  const staticRoutes = new Map<string, Set<string>>([['/', new Set('/')]]);\n  /*\n   * dynamicRoutes are the same as staticRoutes (key if the resolved route,\n   *   and the value is a set of possible routes). e.g:\n   *\n   * /[...fruits] -> /${CatchAllRoutePart<T>}\n   * /color/[color] -> /color/${SingleRoutePart<T>}\n   *\n   * The keys of this map are also important, as they can be used as \"static\" types\n   * <Link href={{ pathname: \"/[...fruits]\",params: { fruits: [\"apple\"] } }} />\n   */\n  const dynamicRoutes = new Map<string, Set<string>>();\n\n  const filePathToRoute = (filePath: string) => {\n    return filePath\n      .replace(appRoot, '')\n      .replace(/index.[jt]sx?/, '')\n      .replace(/\\.[jt]sx?$/, '');\n  };\n\n  const addFilePath = (filePath: string): boolean => {\n    if (filePath.match(/_layout\\.[tj]sx?$/)) {\n      return false;\n    }\n\n    const route = filePathToRoute(filePath);\n\n    // We have already processed this file\n    if (staticRoutes.has(route) || dynamicRoutes.has(route)) {\n      return false;\n    }\n\n    const dynamicParams = new Set(\n      [...route.matchAll(CAPTURE_DYNAMIC_PARAMS)].map((match) => match[1])\n    );\n    const isDynamic = dynamicParams.size > 0;\n\n    const addRoute = (originalRoute: string, route: string) => {\n      if (isDynamic) {\n        let set = dynamicRoutes.get(originalRoute);\n\n        if (!set) {\n          set = new Set();\n          dynamicRoutes.set(originalRoute, set);\n        }\n\n        set.add(\n          route\n            .replaceAll(CATCH_ALL, '${CatchAllRoutePart<T>}')\n            .replaceAll(SLUG, '${SingleRoutePart<T>}')\n        );\n      } else {\n        let set = staticRoutes.get(originalRoute);\n\n        if (!set) {\n          set = new Set();\n          staticRoutes.set(originalRoute, set);\n        }\n\n        set.add(route);\n      }\n    };\n\n    if (!route.match(ARRAY_GROUP_REGEX)) {\n      addRoute(route, route);\n    }\n\n    // Does this route have a group? eg /(group)\n    if (route.includes('/(')) {\n      const routeWithoutGroups = route.replace(/\\/\\(.+?\\)/g, '');\n      addRoute(route, routeWithoutGroups);\n\n      // If there are multiple groups, we need to expand them\n      // eg /(test1,test2)/page => /test1/page & /test2/page\n      for (const routeWithSingleGroup of extrapolateGroupRoutes(route)) {\n        addRoute(route, routeWithSingleGroup);\n      }\n    }\n\n    return true;\n  };\n\n  return {\n    staticRoutes,\n    dynamicRoutes,\n    filePathToRoute,\n    addFilePath,\n  };\n}\n\nexport const setToUnionType = <T>(set: Set<T>) => {\n  return set.size > 0 ? [...set].map((s) => `\\`${s}\\``).join(' | ') : 'never';\n};\n\n/**\n * Recursively walk a directory and call the callback with the file path.\n */\nasync function walk(directory: string, callback: (filePath: string) => void) {\n  const files = await fs.readdir(directory);\n  for (const file of files) {\n    const p = path.join(directory, file);\n    if ((await fs.stat(p)).isDirectory()) {\n      await walk(p, callback);\n    } else {\n      // Normalise the paths so they are easier to convert to URLs\n      const normalizedPath = p.replaceAll(path.sep, '/').replaceAll(' ', '_');\n      callback(normalizedPath);\n    }\n  }\n}\n\n/**\n * Given a route, return all possible routes that could be generated from it.\n */\nexport function extrapolateGroupRoutes(\n  route: string,\n  routes: Set<string> = new Set()\n): Set<string> {\n  // Create a version with no groups. We will then need to cleanup double and/or trailing slashes\n  routes.add(route.replaceAll(ARRAY_GROUP_REGEX, '').replaceAll(/\\/+/g, '/').replace(/\\/$/, ''));\n\n  const match = route.match(ARRAY_GROUP_REGEX);\n\n  if (!match) {\n    routes.add(route);\n    return routes;\n  }\n\n  const groupsMatch = match[0];\n\n  for (const group of groupsMatch.matchAll(CAPTURE_GROUP_REGEX)) {\n    extrapolateGroupRoutes(route.replace(groupsMatch, `(${group[1]})`), routes);\n  }\n\n  return routes;\n}\n\n/**\n * NOTE: This code refers to a specific version of `expo-router` and is therefore unsafe to\n * mix with arbitrary versions.\n * TODO: Version this code with `expo-router` or version expo-router with `@expo/cli`.\n */\nconst routerDotTSTemplate = unsafeTemplate`/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable import/export */\n/* eslint-disable @typescript-eslint/ban-types */\ndeclare module \"expo-router\" {\n  import type { LinkProps as OriginalLinkProps } from 'expo-router/build/link/Link';\n  export * from 'expo-router/build';\n\n  // prettier-ignore\n  type StaticRoutes = ${'staticRoutes'};\n  // prettier-ignore\n  type DynamicRoutes<T extends string> = ${'dynamicRoutes'};\n  // prettier-ignore\n  type DynamicRouteTemplate = ${'dynamicRouteParams'};\n\n  type RelativePathString = \\`./\\${string}\\` | \\`../\\${string}\\` | '..';\n  type AbsoluteRoute = DynamicRouteTemplate | StaticRoutes;\n  type ExternalPathString = \\`http\\${string}\\`;\n  type ExpoRouterRoutes = DynamicRouteTemplate | StaticRoutes | RelativePathString;\n  type AllRoutes = ExpoRouterRoutes | ExternalPathString;\n\n  /****************\n   * Route Utils  *\n   ****************/\n\n  type SearchOrHash = \\`?\\${string}\\` | \\`#\\${string}\\`;\n\n  /**\n   * Return only the RoutePart of a string. If the string has multiple parts return never\n   *\n   * string   | type\n   * ---------|------\n   * 123      | 123\n   * /123/abc | never\n   * 123?abc  | never\n   * ./123    | never\n   * /123     | never\n   * 123/../  | never\n   */\n  type SingleRoutePart<S extends string> = S extends \\`\\${string}/\\${string}\\`\n    ? never\n    : S extends \\`\\${string}\\${SearchOrHash}\\`\n    ? never\n    : S extends ''\n    ? never\n    : S;\n\n  /**\n   * Return only the CatchAll router part. If the string has search parameters or a hash return never\n   */\n  type CatchAllRoutePart<S extends string> = S extends \\`\\${string}\\${SearchOrHash}\\`\n    ? never\n    : S extends ''\n    ? never\n    : S;\n\n  // type OptionalCatchAllRoutePart<S extends string> = S extends \\`\\${string}\\${SearchOrHash}\\` ? never : S\n\n  /**\n   * Return the name of a route parameter\n   * '[test]'    -> 'test'\n   * 'test'      -> never\n   * '[...test]' -> '...test'\n   */\n  type IsParameter<Part> = Part extends \\`[\\${infer ParamName}]\\` ? ParamName : never;\n\n  /**\n   * Return a union of all parameter names. If there are no names return never\n   *\n   * /[test]         -> 'test'\n   * /[abc]/[...def] -> 'abc'|'...def'\n   */\n  type ParameterNames<Path> = Path extends \\`\\${infer PartA}/\\${infer PartB}\\`\n    ? IsParameter<PartA> | ParameterNames<PartB>\n    : IsParameter<Path>;\n\n  /**\n   * Returns all segements of a route.\n   *\n   * /(group)/123/abc/[id]/[...rest] -> ['(group)', '123', 'abc', '[id]', '[...rest]'\n   */\n  type RouteSegments<Path> = Path extends \\`\\${infer PartA}/\\${infer PartB}\\`\n    ? PartA extends '' | '.'\n      ? [...RouteSegments<PartB>]\n      : [PartA, ...RouteSegments<PartB>]\n    : Path extends ''\n    ? []\n    : [Path];\n\n  /**\n   * Returns a Record of the routes parameters as strings and CatchAll parameters as string[]\n   *\n   * /[id]/[...rest] -> { id: string, rest: string[] }\n   * /no-params      -> {}\n   */\n  type RouteParams<Path> = {\n    [Key in ParameterNames<Path> as Key extends \\`...\\${infer Name}\\`\n      ? Name\n      : Key]: Key extends \\`...\\${string}\\` ? string[] : string;\n  };\n\n  /**\n   * Returns the search parameters for a route\n   */\n  export type SearchParams<T extends AllRoutes> = T extends DynamicRouteTemplate\n    ? RouteParams<T>\n    : T extends StaticRoutes\n    ? never\n    : Record<string, string>;\n\n  /**\n   * Route is mostly used as part of Href to ensure that a valid route is provided\n   *\n   * Given a dynamic route, this will return never. This is helpful for conditional logic\n   *\n   * /test         -> /test, /test2, etc\n   * /test/[abc]   -> never\n   * /test/resolve -> /test, /test2, etc\n   *\n   * Note that if we provide a value for [abc] then the route is allowed\n   *\n   * This is named Route to prevent confusion, as users they will often see it in tooltips\n   */\n  export type Route<T> = T extends DynamicRouteTemplate\n    ? never\n    :\n        | StaticRoutes\n        | RelativePathString\n        | ExternalPathString\n        | (T extends DynamicRoutes<infer _> ? T : never);\n\n  /*********\n   * Href  *\n   *********/\n\n  export type Href<T extends string> = Route<T> | HrefObject<T>;\n\n  export type HrefObject<T = AllRoutes> = T extends DynamicRouteTemplate\n    ? { pathname: T; params: RouteParams<T> }\n    : T extends Route<T>\n    ? { pathname: Route<T>; params?: never }\n    : never;\n\n  /***********************\n   * Expo Router Exports *\n   ***********************/\n\n  export type Router = {\n    /** Navigate to the provided href. */\n    push: <T extends string>(href: Href<T>) => void;\n    /** Navigate to route without appending to the history. */\n    replace: <T extends string>(href: Href<T>) => void;\n    /** Go back in the history. */\n    back: () => void;\n    /** Update the current route query params. */\n    setParams: <T extends string = ''>(\n      params?: T extends '' ? Record<string, string> : RouteParams<T>\n    ) => void;\n  };\n\n  /************\n   * <Link /> *\n   ************/\n  export interface LinkProps<T extends string> extends OriginalLinkProps {\n    href: T extends DynamicRouteTemplate ? HrefObject<T> : Href<T>;\n  }\n\n  export interface LinkComponent {\n    <T extends string>(props: React.PropsWithChildren<LinkProps<T>>): JSX.Element;\n    /** Helper method to resolve an Href object into a string. */\n    resolveHref: <T extends string>(href: Href<T>) => string;\n  }\n\n  export const Link: LinkComponent;\n\n  /************\n   * Hooks *\n   ************/\n  export function useRouter(): Router;\n  export function useLocalSearchParams<\n    T extends DynamicRouteTemplate | StaticRoutes | RelativePathString\n  >(): SearchParams<T>;\n  export function useSearchParams<\n    T extends AllRoutes | SearchParams<DynamicRouteTemplate>\n  >(): T extends AllRoutes ? SearchParams<T> : T;\n\n  export function useGlobalSearchParams<\n    T extends AllRoutes | SearchParams<DynamicRouteTemplate>\n  >(): T extends AllRoutes ? SearchParams<T> : T;\n\n  export function useSegments<\n    T extends AbsoluteRoute | RouteSegments<AbsoluteRoute> | RelativePathString\n  >(): T extends AbsoluteRoute ? RouteSegments<T> : T extends string ? string[] : T;\n}\n`;\n"],"names":["setupTypedRoutes","getTemplateString","getTypedRoutesUtils","extrapolateGroupRoutes","CAPTURE_DYNAMIC_PARAMS","CATCH_ALL","SLUG","ARRAY_GROUP_REGEX","CAPTURE_GROUP_REGEX","server","metro","typesDirectory","projectRoot","routerDirectory","appRoot","path","join","filePathToRoute","staticRoutes","dynamicRoutes","addFilePath","metroWatchTypeScriptFiles","eventTypes","callback","filePath","type","shouldRegenerate","route","delete","regenerateRouterDotTS","Set","values","flatMap","v","Array","from","keys","walk","debounce","typesDir","dynamicRouteTemplates","fs","writeFile","resolve","routerDotTSTemplate","setToUnionType","dynamicRouteParams","Map","replace","match","has","dynamicParams","matchAll","map","isDynamic","size","addRoute","originalRoute","set","get","add","replaceAll","includes","routeWithoutGroups","routeWithSingleGroup","s","directory","files","readdir","file","p","stat","isDirectory","normalizedPath","sep","routes","groupsMatch","group","unsafeTemplate"],"mappings":"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"}